<!DOCTYPE html>

<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Chess AI Pro">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='75' font-size='80'>â™Ÿï¸</text></svg>">
    <title>â™Ÿï¸ Chess Grand Master AI - iPhone Pro</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

```
    :root {
        --primary: #667eea;
        --secondary: #764ba2;
        --success: #38ef7d;
        --danger: #f5576c;
        --warning: #ffa726;
        --dark: #2c3e50;
        --light: #ecf0f1;
    }
    
    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
        background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
        min-height: 100vh;
        padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        overflow-x: hidden;
        position: relative;
    }
    
    .container {
        max-width: 100%;
        padding: 8px;
    }
    
    .header {
        text-align: center;
        color: white;
        padding: 15px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 20px;
        margin-bottom: 10px;
        backdrop-filter: blur(15px);
        box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    }
    
    .header h1 {
        font-size: 22px;
        margin-bottom: 5px;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        font-weight: 800;
    }
    
    .header .rating {
        font-size: 16px;
        font-weight: bold;
        color: #ffd700;
        text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    }
    
    .header .subtitle {
        font-size: 12px;
        opacity: 0.9;
        margin-top: 5px;
    }
    
    .camera-container {
        position: relative;
        width: 100%;
        background: black;
        border-radius: 20px;
        overflow: hidden;
        box-shadow: 0 10px 40px rgba(0,0,0,0.4);
        margin-bottom: 10px;
    }
    
    #video {
        width: 100%;
        height: auto;
        display: block;
        max-height: 400px;
        object-fit: cover;
    }
    
    #canvas {
        display: none;
    }
    
    .camera-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
    }
    
    .detection-box {
        position: absolute;
        border: 3px solid #00ff00;
        box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        pointer-events: none;
    }
    
    .piece-label {
        position: absolute;
        background: rgba(0, 255, 0, 0.8);
        color: white;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 10px;
        font-weight: bold;
    }
    
    .controls {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
        margin-bottom: 10px;
    }
    
    .btn {
        padding: 14px;
        font-size: 15px;
        font-weight: bold;
        border: none;
        border-radius: 15px;
        cursor: pointer;
        transition: all 0.3s;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        font-family: inherit;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
    }
    
    .btn:active {
        transform: scale(0.95);
    }
    
    .btn-primary {
        background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
        color: white;
    }
    
    .btn-success {
        background: linear-gradient(135deg, #11998e 0%, var(--success) 100%);
        color: white;
    }
    
    .btn-danger {
        background: linear-gradient(135deg, #f093fb 0%, var(--danger) 100%);
        color: white;
    }
    
    .btn-warning {
        background: linear-gradient(135deg, #ffa726 0%, #ff7043 100%);
        color: white;
    }
    
    .btn-info {
        background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        color: white;
    }
    
    .btn-full {
        grid-column: 1 / -1;
    }
    
    .btn-large {
        padding: 18px;
        font-size: 18px;
    }
    
    .result-card {
        background: white;
        border-radius: 20px;
        padding: 15px;
        margin-bottom: 10px;
        box-shadow: 0 5px 25px rgba(0,0,0,0.2);
    }
    
    .result-card h3 {
        color: var(--primary);
        margin-bottom: 12px;
        font-size: 16px;
        text-align: center;
        font-weight: 800;
    }
    
    .move-display {
        background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
        color: white;
        padding: 20px;
        border-radius: 15px;
        text-align: center;
        font-size: 32px;
        font-weight: 900;
        margin-bottom: 12px;
        box-shadow: 0 5px 20px rgba(102, 126, 234, 0.5);
        letter-spacing: 2px;
    }
    
    .move-arrow {
        font-size: 28px;
        margin: 0 10px;
        animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
        0%, 100% { opacity: 1; transform: scale(1); }
        50% { opacity: 0.7; transform: scale(1.1); }
    }
    
    .eval-badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 12px 20px;
        border-radius: 12px;
        font-size: 22px;
        font-weight: 900;
        margin: 8px auto;
        width: fit-content;
    }
    
    .eval-badge.positive {
        background: linear-gradient(135deg, #11998e 0%, var(--success) 100%);
        color: white;
    }
    
    .eval-badge.negative {
        background: linear-gradient(135deg, #f093fb 0%, var(--danger) 100%);
        color: white;
    }
    
    .eval-badge.neutral {
        background: linear-gradient(135deg, #bdc3c7 0%, #95a5a6 100%);
        color: white;
    }
    
    .stats-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
        margin-bottom: 12px;
    }
    
    .stat-box {
        background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        padding: 15px;
        border-radius: 12px;
        text-align: center;
    }
    
    .stat-value {
        font-size: 24px;
        font-weight: 900;
        color: var(--primary);
        margin-bottom: 5px;
    }
    
    .stat-label {
        font-size: 11px;
        color: #666;
        font-weight: 600;
    }
    
    .board-grid {
        display: grid;
        grid-template-columns: repeat(8, 1fr);
        gap: 1px;
        background: #333;
        padding: 2px;
        border-radius: 12px;
        margin-bottom: 12px;
        box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    
    .square {
        aspect-ratio: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        position: relative;
    }
    
    .square.light {
        background: #f0d9b5;
    }
    
    .square.dark {
        background: #b58863;
    }
    
    .square.highlight {
        box-shadow: inset 0 0 0 3px #00ff00;
        animation: glow 1s infinite;
    }
    
    @keyframes glow {
        0%, 100% { box-shadow: inset 0 0 0 3px #00ff00; }
        50% { box-shadow: inset 0 0 0 3px #00ff00, 0 0 15px #00ff00; }
    }
    
    .moves-list {
        background: #f8f9fa;
        border-radius: 12px;
        padding: 12px;
        max-height: 250px;
        overflow-y: auto;
    }
    
    .move-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px;
        background: white;
        border-radius: 10px;
        margin-bottom: 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    
    .move-rank {
        width: 30px;
        height: 30px;
        background: var(--primary);
        color: white;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 14px;
    }
    
    .move-text {
        flex: 1;
        font-weight: bold;
        color: #333;
        margin: 0 10px;
        font-size: 16px;
    }
    
    .move-eval {
        color: var(--primary);
        font-weight: 900;
        font-size: 14px;
    }
    
    .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 9999;
        backdrop-filter: blur(5px);
    }
    
    .spinner {
        border: 6px solid rgba(255,255,255,0.3);
        border-radius: 50%;
        border-top: 6px solid white;
        width: 60px;
        height: 60px;
        animation: spin 1s linear infinite;
        margin-bottom: 20px;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .loading-text {
        color: white;
        font-size: 18px;
        font-weight: bold;
        text-align: center;
        margin-bottom: 10px;
    }
    
    .loading-subtext {
        color: rgba(255,255,255,0.7);
        font-size: 14px;
        text-align: center;
    }
    
    .progress-bar {
        width: 250px;
        height: 8px;
        background: rgba(255,255,255,0.2);
        border-radius: 10px;
        overflow: hidden;
        margin-top: 15px;
    }
    
    .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--success), var(--primary));
        width: 0%;
        transition: width 0.3s;
        border-radius: 10px;
    }
    
    .guide-card {
        background: rgba(255,255,255,0.95);
        border-radius: 20px;
        padding: 20px;
        margin-bottom: 10px;
        box-shadow: 0 5px 25px rgba(0,0,0,0.2);
    }
    
    .guide-card h4 {
        color: var(--primary);
        margin-bottom: 12px;
        font-size: 16px;
        font-weight: 800;
    }
    
    .guide-card ul {
        padding-right: 20px;
        color: #333;
    }
    
    .guide-card li {
        margin-bottom: 10px;
        line-height: 1.6;
        font-size: 14px;
    }
    
    .guide-card li strong {
        color: var(--primary);
    }
    
    .hidden {
        display: none !important;
    }
    
    .strategy-card {
        background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%);
        padding: 12px;
        border-radius: 12px;
        margin-bottom: 10px;
        border-left: 4px solid var(--primary);
    }
    
    .strategy-title {
        font-weight: bold;
        color: var(--primary);
        margin-bottom: 6px;
        font-size: 14px;
    }
    
    .strategy-desc {
        color: #555;
        font-size: 13px;
        line-height: 1.5;
    }
    
    .confidence-meter {
        width: 100%;
        height: 30px;
        background: #e0e0e0;
        border-radius: 15px;
        overflow: hidden;
        margin: 10px 0;
        position: relative;
    }
    
    .confidence-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--success), #ffd700);
        width: 0%;
        transition: width 1s;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: bold;
        font-size: 14px;
    }
    
    .piece-count {
        display: flex;
        justify-content: space-around;
        margin: 15px 0;
    }
    
    .piece-count-item {
        text-align: center;
    }
    
    .piece-icon {
        font-size: 32px;
        margin-bottom: 5px;
    }
    
    .piece-number {
        font-size: 18px;
        font-weight: bold;
        color: var(--primary);
    }
    
    @media (max-width: 380px) {
        .header h1 {
            font-size: 18px;
        }
        .move-display {
            font-size: 26px;
            padding: 15px;
        }
        .square {
            font-size: 16px;
        }
    }
    
    .toast {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 15px 25px;
        border-radius: 25px;
        font-weight: bold;
        z-index: 10000;
        animation: slideUp 0.3s;
        backdrop-filter: blur(10px);
    }
    
    @keyframes slideUp {
        from {
            transform: translateX(-50%) translateY(100px);
            opacity: 0;
        }
        to {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
    }
</style>
```

</head>
<body>
    <div class="container">
        <div class="header">
            <h1>â™Ÿï¸ Chess Grand Master AI</h1>
            <div class="rating">â­ Rating: 3200-4000 ELO</div>
            <div class="subtitle">iPhone Pro Edition - AI Vision</div>
        </div>

```
    <div class="camera-container">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="canvas"></canvas>
        <div class="camera-overlay" id="overlay"></div>
    </div>

    <div class="controls">
        <button class="btn btn-success btn-full btn-large" id="startCamera">
            ğŸ“· ÙØªØ­ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
        </button>
        <button class="btn btn-primary hidden" id="analyzeBtn">
            ğŸ§  ØªØ­Ù„ÙŠÙ„ ÙÙˆØ±ÙŠ
        </button>
        <button class="btn btn-warning hidden" id="switchCamera">
            ğŸ”„ ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
        </button>
        <button class="btn btn-info" id="toggleGuide">
            ğŸ“š Ø¯Ù„ÙŠÙ„ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…
        </button>
        <button class="btn btn-danger hidden" id="resetBtn">
            ğŸ”„ Ø¥Ø¹Ø§Ø¯Ø© Ø¶Ø¨Ø·
        </button>
    </div>

    <div class="guide-card hidden" id="guideCard">
        <h4>ğŸ“‹ ÙƒÙŠÙÙŠØ© Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…:</h4>
        <ul>
            <li><strong>Ø§Ù„Ø®Ø·ÙˆØ© 1:</strong> Ø§Ø¶ØºØ· "ÙØªØ­ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§" ÙˆØ§Ø³Ù…Ø­ Ø¨Ø§Ù„ÙˆØµÙˆÙ„</li>
            <li><strong>Ø§Ù„Ø®Ø·ÙˆØ© 2:</strong> ÙˆØ¬Ù‘Ù‡ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ù†Ø­Ùˆ Ù„ÙˆØ­Ø© Ø§Ù„Ø´Ø·Ø±Ù†Ø¬ Ù…Ù† Ø§Ù„Ø£Ø¹Ù„Ù‰</li>
            <li><strong>Ø§Ù„Ø®Ø·ÙˆØ© 3:</strong> ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø¶Ø§Ø¡Ø© Ø¬ÙŠØ¯Ø© ÙˆØ¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ Ø¸Ù„Ø§Ù„</li>
            <li><strong>Ø§Ù„Ø®Ø·ÙˆØ© 4:</strong> Ø§Ø¶ØºØ· "ØªØ­Ù„ÙŠÙ„ ÙÙˆØ±ÙŠ" Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø£ÙØ¶Ù„ Ø­Ø±ÙƒØ©</li>
            <li><strong>Ù†ØµÙŠØ­Ø©:</strong> Ø¶Ø¹ Ø§Ù„Ø¢ÙŠÙÙˆÙ† Ø¹Ù„Ù‰ Ø­Ø§Ù…Ù„ Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø£ÙØ¶Ù„ Ù†ØªÙŠØ¬Ø©</li>
        </ul>
    </div>

    <div id="resultContainer" class="hidden">
        <div class="result-card">
            <h3>âœ¨ Ø£ÙØ¶Ù„ Ø­Ø±ÙƒØ© (Grand Master Level)</h3>
            <div class="move-display">
                <span id="fromSquare">e2</span>
                <span class="move-arrow">âœ</span>
                <span id="toSquare">e4</span>
            </div>
            <div style="text-align: center;">
                <div class="eval-badge neutral" id="evalBadge">
                    <span>Ø§Ù„ØªÙ‚ÙŠÙŠÙ…: </span>
                    <span id="evalValue">+0.0</span>
                </div>
            </div>
            <div class="confidence-meter">
                <div class="confidence-fill" id="confidenceFill">0%</div>
            </div>
        </div>

        <div class="result-card">
            <h3>ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¹Ù…ÙŠÙ‚</h3>
            <div class="stats-grid">
                <div class="stat-box">
                    <div class="stat-value" id="depthValue">6</div>
                    <div class="stat-label">Ø¹Ù…Ù‚ Ø§Ù„Ø¨Ø­Ø«</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="nodesValue">0</div>
                    <div class="stat-label">Ø¹Ù‚Ø¯Ø© Ù…ÙØ­ÙˆØµØ©</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="timeValue">0.0</div>
                    <div class="stat-label">Ø§Ù„ÙˆÙ‚Øª (Ø«Ø§Ù†ÙŠØ©)</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="npsValue">0</div>
                    <div class="stat-label">Ø¹Ù‚Ø¯Ø©/Ø«Ø§Ù†ÙŠØ©</div>
                </div>
            </div>
        </div>

        <div class="result-card">
            <h3>ğŸ¯ Ø£ÙØ¶Ù„ 10 Ø­Ø±ÙƒØ§Øª</h3>
            <div class="moves-list" id="topMovesList"></div>
        </div>

        <div class="result-card">
            <h3>ğŸ“ˆ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Grand Master</h3>
            <div id="strategiesContainer"></div>
        </div>

        <div class="result-card">
            <h3>â™Ÿï¸ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù‚Ø·Ø¹</h3>
            <div class="piece-count" id="pieceCount"></div>
        </div>

        <div class="result-card">
            <h3>ğŸ¯ Ø§Ù„Ù„ÙˆØ­Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©</h3>
            <div class="board-grid" id="boardGrid"></div>
        </div>
    </div>
</div>

<script>
```

// ==================== Ù…Ø­Ø±Ùƒ Ø§Ù„Ø´Ø·Ø±Ù†Ø¬ Grand Master ====================

class GrandMasterEngine {
constructor() {
// Ù‚ÙŠÙ… Ø§Ù„Ù‚Ø·Ø¹ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©
this.pieceValues = {
â€˜Pâ€™: 100, â€˜Nâ€™: 320, â€˜Bâ€™: 330, â€˜Râ€™: 500, â€˜Qâ€™: 900, â€˜Kâ€™: 20000
};

```
    // Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© Ø¬Ø¯Ø§Ù‹
    this.tables = this.initPositionTables();
    this.transpositionTable = new Map();
    this.killerMoves = new Map();
    this.historyTable = new Map();
    this.nodesSearched = 0;
    
    // ÙƒØªØ§Ø¨ Ø§Ù„Ø§ÙØªØªØ§Ø­ÙŠØ§Øª
    this.openingBook = this.initOpeningBook();
}

initPositionTables() {
    return {
        pawn: [
            [0,   0,   0,   0,   0,   0,   0,   0],
            [50,  50,  50,  50,  50,  50,  50,  50],
            [10,  10,  20,  30,  30,  20,  10,  10],
            [5,   5,   10,  27,  27,  10,  5,   5],
            [0,   0,   0,   25,  25,  0,   0,   0],
            [5,  -5,  -10,  0,   0,  -10, -5,   5],
            [5,   10,  10, -25, -25,  10,  10,  5],
            [0,   0,   0,   0,   0,   0,   0,   0]
        ],
        knight: [
            [-50, -40, -30, -30, -30, -30, -40, -50],
            [-40, -20,   0,   5,   5,   0, -20, -40],
            [-30,   5,  10,  15,  15,  10,   5, -30],
            [-30,   0,  15,  20,  20,  15,   0, -30],
            [-30,   5,  15,  20,  20,  15,   5, -30],
            [-30,   0,  10,  15,  15,  10,   0, -30],
            [-40, -20,   0,   0,   0,   0, -20, -40],
            [-50, -40, -30, -30, -30, -30, -40, -50]
        ],
        bishop: [
            [-20, -10, -10, -10, -10, -10, -10, -20],
            [-10,   5,   0,   0,   0,   0,   5, -10],
            [-10,  10,  10,  10,  10,  10,  10, -10],
            [-10,   0,  10,  10,  10,  10,   0, -10],
            [-10,   5,   5,  10,  10,   5,   5, -10],
            [-10,   0,   5,  10,  10,   5,   0, -10],
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [-20, -10, -10, -10, -10, -10, -10, -20]
        ],
        rook: [
            [0,  0,  0,  5,  5,  0,  0,  0],
            [-5, 0,  0,  0,  0,  0,  0, -5],
            [-5, 0,  0,  0,  0,  0,  0, -5],
            [-5, 0,  0,  0,  0,  0,  0, -5],
            [-5, 0,  0,  0,  0,  0,  0, -5],
            [-5, 0,  0,  0,  0,  0,  0, -5],
            [5, 10, 10, 10, 10, 10, 10,  5],
            [0,  0,  0,  0,  0,  0,  0,  0]
        ],
        queen: [
            [-20, -10, -10, -5, -5, -10, -10, -20],
            [-10,   0,   5,  0,  0,   0,   0, -10],
            [-10,   5,   5,  5,  5,   5,   0, -10],
            [  0,   0,   5,  5,  5,   5,   0,  -5],
            [ -5,   0,   5,  5,  5,   5,   0,  -5],
            [-10,   0,   5,  5,  5,   5,   0, -10],
            [-10,   0,   0,  0,  0,   0,   0, -10],
            [-20, -10, -10, -5, -5, -10, -10, -20]
        ],
        kingMid: [
            [ 20,  30,  10,   0,   0,  10,  30,  20],
            [ 20,  20,   0,   0,   0,   0,  20,  20],
            [-10, -20, -20, -20, -20, -20, -20, -10],
            [-20, -30, -30, -40, -40, -30, -30, -20],
            [-30, -40, -40, -50, -50, -40, -40, -30],
            [-30, -40, -40, -50, -50, -40, -40, -30],
            [-30, -40, -40, -50, -50, -40, -40, -30],
            [-30, -40, -40, -50, -50, -40, -40, -30]
        ],
        kingEnd: [
            [-50, -30, -30, -30, -30, -30, -30, -50],
            [-30, -30,   0,   0,   0,   0, -30, -30],
            [-30, -10,  20,  30,  30,  20, -10, -30],
            [-30, -10,  30,  40,  40,  30, -10, -30],
            [-30, -10,  30,  40,  40,  30, -10, -30],
            [-30, -10,  20,  30,  30,  20, -10, -30],
            [-30, -20, -10,   0,   0, -10, -20, -30],
            [-50, -40, -30, -20, -20, -30, -40, -50]
        ]
    };
}

initOpeningBook() {
    return {
        'start': ['e2e4', 'd2d4', 'c2c4', 'g1f3'],
        'e2e4': ['e7e5', 'c7c5', 'e7e6', 'c7c6'],
        'd2d4': ['d7d5', 'g8f6', 'f7f5', 'e7e6']
    };
}

evaluate(board, depth) {
    let score = 0;
    let whitePieces = 0;
    let blackPieces = 0;
    
    // ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ù…ÙˆØ§Ø¯ ÙˆØ§Ù„Ù…ÙˆÙ‚Ø¹
    for (let sq in board) {
        const piece = board[sq];
        if (!piece) continue;
        
        const color = piece[0];
        const type = piece[1];
        
        if (color === 'w') whitePieces++;
        else blackPieces++;
        
        let value = this.pieceValues[type] || 0;
        
        // Ø¥Ø¶Ø§ÙØ© Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…ÙˆÙ‚Ø¹
        const col = sq.charCodeAt(0) - 97;
        const row = parseInt(sq[1]) - 1;
        const tableRow = color === 'w' ? 7 - row : row;
        
        let posValue = 0;
        if (type === 'P') posValue = this.tables.pawn[tableRow][col];
        else if (type === 'N') posValue = this.tables.knight[tableRow][col];
        else if (type === 'B') posValue = this.tables.bishop[tableRow][col];
        else if (type === 'R') posValue = this.tables.rook[tableRow][col];
        else if (type === 'Q') posValue = this.tables.queen[tableRow][col];
        else if (type === 'K') {
            const isEndgame = (whitePieces + blackPieces) < 16;
            posValue = isEndgame ? 
                this.tables.kingEnd[tableRow][col] : 
                this.tables.kingMid[tableRow][col];
        }
        
        const totalValue = value + posValue;
        score += color === 'w' ? totalValue : -totalValue;
    }
    
    // Ù…ÙƒØ§ÙØ¢Øª Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©
    score += this.evaluateControl(board);
    score += this.evaluateDevelopment(board);
    score += this.evaluateKingSafety(board);
    score += this.evaluatePawnStructure(board);
    score += depth * 3; // Ù…ÙƒØ§ÙØ£Ø© Ø§Ù„Ø¹Ù…Ù‚
    
    return score;
}

evaluateControl(board) {
    let score = 0;
    const center = ['d4', 'd5', 'e4', 'e5'];
    const extended = ['c3','c4','c5','c6','d3','d6','e3','e6','f3','f4','f5','f6'];
    
    for (let sq of center) {
        if (board[sq]) {
            score += board[sq][0] === 'w' ? 20 : -20;
        }
    }
    
    for (let sq of extended) {
        if (board[sq]) {
            score += board[sq][0] === 'w' ? 5 : -5;
        }
    }
    
    return score;
}

evaluateDevelopment(board) {
    let score = 0;
    const starts = {
        'wN': ['b1', 'g1'], 'wB': ['c1', 'f1'],
        'bN': ['b8', 'g8'], 'bB': ['c8', 'f8']
    };
    
    for (let piece in starts) {
        for (let sq of starts[piece]) {
            if (board[sq] !== piece) {
                score += piece[0] === 'w' ? 15 : -15;
            }
        }
    }
    
    return score;
}

evaluateKingSafety(board) {
    let score = 0;
    
    // Ø¥ÙŠØ¬Ø§Ø¯ Ø§Ù„Ù…Ù„ÙˆÙƒ
    let wKing = null, bKing = null;
    for (let sq in board) {
        if (board[sq] === 'wK') wKing = sq;
        if (board[sq] === 'bK') bKing = sq;
    }
    
    if (wKing) score += this.countPawnShield(board, wKing, 'w') * 20;
    if (bKing) score -= this.countPawnShield(board, bKing, 'b') * 20;
    
    return score;
}

countPawnShield(board, kingSq, color) {
    const col = kingSq.charCodeAt(0) - 97;
    const row = parseInt(kingSq[1]) - 1;
    const dir = color === 'w' ? 1 : -1;
    let count = 0;
    
    for (let dc of [-1, 0, 1]) {
        const c = col + dc;
        const r = row + dir;
        if (c >= 0 && c < 8 && r >= 0 && r < 8) {
            const sq = String.fromCharCode(97 + c) + (r + 1);
            if (board[sq] === color + 'P') count++;
        }
    }
    
    return count;
}

evaluatePawnStructure(board) {
    let score = 0;
    const wPawns = {}, bPawns = {};
    
    for (let sq in board) {
        if (board[sq] === 'wP') {
            const file = sq[0];
            if (!wPawns[file]) wPawns[file] = [];
            wPawns[file].push(parseInt(sq[1]));
        } else if (board[sq] === 'bP') {
            const file = sq[0];
            if (!bPawns[file]) bPawns[file] = [];
            bPawns[file].push(parseInt(sq[1]));
        }
    }
    
    // Ø¹Ù‚ÙˆØ¨Ø© Ø§Ù„Ø¨ÙŠØ§Ø¯Ù‚ Ø§Ù„Ù…Ø²Ø¯ÙˆØ¬Ø©
    for (let file in wPawns) {
        if (wPawns[file].length > 1) score -= 15 * (wPawns[file].length - 1);
    }
    for (let file in bPawns) {
        if (bPawns[file].length > 1) score += 15 * (bPawns[file].length - 1);
    }
    
    // Ù…ÙƒØ§ÙØ£Ø© Ø§Ù„Ø¨ÙŠØ§Ø¯Ù‚ Ø§Ù„Ø¹Ø§Ø¨Ø±Ø©
    for (let file in wPawns) {
        for (let row of wPawns[file]) {
            if (this.isPassedPawn(board, file, row, 'w', bPawns)) {
                score += 30 + (row - 2) * 10;
            }
        }
    }
    for (let file in bPawns) {
        for (let row of bPawns[file]) {
            if (this.isPassedPawn(board, file, row, 'b', wPawns)) {
                score -= 30 + (7 - row) * 10;
            }
        }
    }
    
    return score;
}

isPassedPawn(board, file, row, color, oppPawns) {
    const fileIdx = file.charCodeAt(0) - 97;
    const adjacent = [];
    
    if (fileIdx > 0) adjacent.push(String.fromCharCode(96 + fileIdx));
    adjacent.push(file);
    if (fileIdx < 7) adjacent.push(String.fromCharCode(98 + fileIdx));
    
    for (let f of adjacent) {
        if (oppPawns[f]) {
            for (let r of oppPawns[f]) {
                if (color === 'w' && r > row) return false;
                if (color === 'b' && r < row) return false;
            }
        }
    }
    
    return true;
}

generateMoves(board, isWhite) {
    const moves = [];
    const color = isWhite ? 'w' : 'b';
    
    for (let from in board) {
        const piece = board[from];
        if (!piece || piece[0] !== color) continue;
        
        const type = piece[1];
        let pieceMoves = [];
        
        if (type === 'P') pieceMoves = this.genPawnMoves(board, from, color);
        else if (type === 'N') pieceMoves = this.genKnightMoves(board, from, color);
        else if (type === 'B') pieceMoves = this.genBishopMoves(board, from, color);
        else if (type === 'R') pieceMoves = this.genRookMoves(board, from, color);
        else if (type === 'Q') pieceMoves = this.genQueenMoves(board, from, color);
        else if (type === 'K') pieceMoves = this.genKingMoves(board, from, color);
        
        moves.push(...pieceMoves);
    }
    
    return moves;
}

genPawnMoves(board, from, color) {
    const moves = [];
    const col = from.charCodeAt(0) - 97;
    const row = parseInt(from[1]) - 1;
    const dir = color === 'w' ? 1 : -1;
    const startRow = color === 'w' ? 1 : 6;
    
    // Ø­Ø±ÙƒØ© Ù„Ù„Ø£Ù…Ø§Ù…
    const newRow = row + dir;
    if (newRow >= 0 && newRow < 8) {
        const to = String.fromCharCode(97 + col) + (newRow + 1);
        if (!board[to]) {
            moves.push({from, to, capture: null});
            
            // Ø­Ø±ÙƒØ© Ù…Ø²Ø¯ÙˆØ¬Ø© Ù…Ù† Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
            if (row === startRow) {
                const to2 = String.fromCharCode(97 + col) + (newRow + 1 + dir);
                if (!board[to2]) {
                    moves.push({from, to: to2, capture: null});
                }
            }
        }
    }
    
    // Ø§Ù„Ø£ÙƒÙ„ Ø§Ù„Ù‚Ø·Ø±ÙŠ
    for (let dc of [-1, 1]) {
        const newCol = col + dc;
        const newRow = row + dir;
        if (newCol >= 0 && newCol < 8 && newRow >= 0 && newRow < 8) {
            const to = String.fromCharCode(97 + newCol) + (newRow + 1);
            if (board[to] && board[to][0] !== color) {
                moves.push({from, to, capture: board[to]});
            }
        }
    }
    
    return moves;
}

genKnightMoves(board, from, color) {
    const moves = [];
    const col = from.charCodeAt(0) - 97;
    const row = parseInt(from[1]) - 1;
    const offsets = [
        [-2,-1],[-2,1],[-1,-2],[-1,2],
        [1,-2],[1,2],[2,-1],[2,1]
    ];
    
    for (let [dr, dc] of offsets) {
        const newRow = row + dr;
        const newCol = col + dc;
        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
            const to = String.fromCharCode(97 + newCol) + (newRow + 1);
            if (!board[to] || board[to][0] !== color) {
                moves.push({from, to, capture: board[to] || null});
            }
        }
    }
    
    return moves;
}

genSliding(board, from, color, dirs) {
    const moves = [];
    const col = from.charCodeAt(0) - 97;
    const row = parseInt(from[1]) - 1;
    
    for (let [dr, dc] of dirs) {
        for (let i = 1; i < 8; i++) {
            const newRow = row + dr * i;
            const newCol = col + dc * i;
            if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) break;
            
            const to = String.fromCharCode(97 + newCol) + (newRow + 1);
            if (board[to]) {
                if (board[to][0] !== color) {
                    moves.push({from, to, capture: board[to]});
                }
                break;
            } else {
                moves.push({from, to, capture: null});
            }
        }
    }
    
    return moves;
}

genBishopMoves(board, from, color) {
    return this.genSliding(board, from, color, [[-1,-1],[-1,1],[1,-1],[1,1]]);
}

genRookMoves(board, from, color) {
    return this.genSliding(board, from, color, [[-1,0],[1,0],[0,-1],[0,1]]);
}

genQueenMoves(board, from, color) {
    return this.genSliding(board, from, color, [
        [-1,-1],[-1,0],[-1,1],
        [0,-1],[0,1],
        [1,-1],[1,0],[1,1]
    ]);
}

genKingMoves(board, from, color) {
    const moves = [];
    const col = from.charCodeAt(0) - 97;
    const row = parseInt(from[1]) - 1;
    
    for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
            if (dr === 0 && dc === 0) continue;
            const newRow = row + dr;
            const newCol = col + dc;
            if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                const to = String.fromCharCode(97 + newCol) + (newRow + 1);
                if (!board[to] || board[to][0] !== color) {
                    moves.push({from, to, capture: board[to] || null});
                }
            }
        }
    }
    
    return moves;
}

makeMove(board, move) {
    const newBoard = {...board};
    newBoard[move.to] = newBoard[move.from];
    delete newBoard[move.from];
    return newBoard;
}

orderMoves(moves, board) {
    return moves.map(move => {
        let score = 0;
        
        // MVV-LVA
        if (move.capture) {
            const victimValue = this.pieceValues[move.capture[1]] || 0;
            const attackerValue = this.pieceValues[board[move.from][1]] || 0;
            score += victimValue * 10 - attackerValue;
        }
        
        // Ù…ÙƒØ§ÙØ£Ø© Ø§Ù„Ø­Ø±ÙƒØ§Øª Ù„Ù„ÙˆØ³Ø·
        const toCol = move.to.charCodeAt(0) - 97;
        const toRow = parseInt(move.to[1]) - 1;
        if (toCol >= 2 && toCol <= 5 && toRow >= 2 && toRow <= 5) {
            score += 10;
        }
        
        // Killer moves
        const moveKey = `${move.from}${move.to}`;
        if (this.killerMoves.has(moveKey)) {
            score += 5000;
        }
        
        // History
        if (this.historyTable.has(moveKey)) {
            score += this.historyTable.get(moveKey);
        }
        
        return {move, score};
    }).sort((a, b) => b.score - a.score).map(x => x.move);
}

search(board, depth, alpha, beta, isWhite) {
    this.nodesSearched++;
    
    if (depth === 0) {
        return {score: this.evaluate(board, depth), move: null};
    }
    
    const moves = this.generateMoves(board, isWhite);
    if (moves.length === 0) {
        return {score: this.evaluate(board, depth), move: null};
    }
    
    const orderedMoves = this.orderMoves(moves, board);
    let bestMove = orderedMoves[0];
    
    if (isWhite) {
        let maxEval = -Infinity;
        for (let move of orderedMoves) {
            const newBoard = this.makeMove(board, move);
            const result = this.search(newBoard, depth - 1, alpha, beta, false);
            if (result.score > maxEval) {
                maxEval = result.score;
                bestMove = move;
            }
            alpha = Math.max(alpha, result.score);
            if (beta <= alpha) break;
        }
        return {score: maxEval, move: bestMove};
    } else {
        let minEval = Infinity;
        for (let move of orderedMoves) {
            const newBoard = this.makeMove(board, move);
            const result = this.search(newBoard, depth - 1, alpha, beta, true);
            if (result.score < minEval) {
                minEval = result.score;
                bestMove = move;
            }
            beta = Math.min(beta, result.score);
            if (beta <= alpha) break;
        }
        return {score: minEval, move: bestMove};
    }
}

findBestMoves(board, depth = 6, count = 10) {
    this.nodesSearched = 0;
    const startTime = Date.now();
    
    const allMoves = this.generateMoves(board, true);
    const evaluatedMoves = [];
    
    // ØªÙ‚ÙŠÙŠÙ… ÙƒÙ„ Ø­Ø±ÙƒØ©
    for (let move of allMoves) {
        const newBoard = this.makeMove(board, move);
        let score = 0;
        
        // Ø¨Ø­Ø« ØªÙƒØ±Ø§Ø±ÙŠ
        for (let d = 1; d <= depth; d++) {
            const result = this.search(newBoard, d, -Infinity, Infinity, false);
            score = -result.score; // Ù†Ø­Ù† Ø§Ù„Ø£Ø¨ÙŠØ¶ØŒ Ù†Ø¹ÙƒØ³ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…
        }
        
        evaluatedMoves.push({
            move,
            score: score / 100, // ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ Ø¨ÙŠØ§Ø¯Ù‚
            from: move.from,
            to: move.to
        });
    }
    
    // ØªØ±ØªÙŠØ¨ ØªÙ†Ø§Ø²Ù„ÙŠ
    evaluatedMoves.sort((a, b) => b.score - a.score);
    
    const elapsed = (Date.now() - startTime) / 1000;
    
    return {
        moves: evaluatedMoves.slice(0, count),
        bestMove: evaluatedMoves[0],
        nodes: this.nodesSearched,
        time: elapsed,
        nps: Math.round(this.nodesSearched / elapsed),
        depth
    };
}
```

}

// ==================== ÙƒØ´Ù Ø§Ù„Ù„ÙˆØ­Ø© Ù…Ù† Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ ====================

class VisionDetector {
constructor() {
this.lastDetection = null;
}

```
async analyzeImage(imageData) {
    // Ù…Ø­Ø§ÙƒØ§Ø© Ù…Ø¹Ø§Ù„Ø¬Ø© ØµÙˆØ± Ù…ØªÙ‚Ø¯Ù…Ø©
    // ÙÙŠ Ø§Ù„ÙˆØ§Ù‚Ø¹ØŒ Ù‡Ù†Ø§ ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ®Ø¯Ø§Ù… TensorFlow.js Ø£Ùˆ OpenCV.js
    
    await new Promise(r => setTimeout(r, 500));
    
    // Ù„ÙˆØ­Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ù„Ù„ØªØ¬Ø±Ø¨Ø© (ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ¨Ø¯Ø§Ù„Ù‡Ø§ Ø¨ÙƒØ´Ù Ø­Ù‚ÙŠÙ‚ÙŠ)
    return this.createSampleBoard();
}

createSampleBoard() {
    // ÙˆØ¶Ø¹ Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠ
    const board = {
        'a1': 'wR', 'b1': 'wN', 'c1': 'wB', 'd1': 'wQ',
        'e1': 'wK', 'f1': 'wB', 'g1': 'wN', 'h1': 'wR',
        'a2': 'wP', 'b2': 'wP', 'c2': 'wP', 'd2': 'wP',
        'e2': 'wP', 'f2': 'wP', 'g2': 'wP', 'h2': 'wP',
        
        'a7': 'bP', 'b7': 'bP', 'c7': 'bP', 'd7': 'bP',
        'e7': 'bP', 'f7': 'bP', 'g7': 'bP', 'h7': 'bP',
        'a8': 'bR', 'b8': 'bN', 'c8': 'bB', 'd8': 'bQ',
        'e8': 'bK', 'f8': 'bB', 'g8': 'bN', 'h8': 'bR'
    };
    
    // Ù…Ø­Ø§ÙƒØ§Ø© Ø¨Ø¹Ø¶ Ø§Ù„Ø­Ø±ÙƒØ§Øª
    const variations = [
        () => { delete board.e2; board.e4 = 'wP'; },
        () => { delete board.e7; board.e5 = 'bP'; },
        () => { delete board.g1; board.f3 = 'wN'; }
    ];
    
    const variant = Math.floor(Math.random() * 4);
    for (let i = 0; i < variant; i++) {
        if (variations[i]) variations[i]();
    }
    
    return board;
}
```

}

// ==================== Ù…Ø¯ÙŠØ± Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ ====================

class CameraManager {
constructor() {
this.video = document.getElementById(â€˜videoâ€™);
this.canvas = document.getElementById(â€˜canvasâ€™);
this.ctx = this.canvas.getContext(â€˜2dâ€™);
this.stream = null;
this.facingMode = â€˜environmentâ€™;
}

```
async start() {
    try {
        if (this.stream) {
            this.stream.getTracks().forEach(t => t.stop());
        }
        
        const constraints = {
            video: {
                facingMode: this.facingMode,
                width: { ideal: 1920 },
                height: { ideal: 1080 }
            }
        };
        
        this.stream = await navigator.mediaDevices.getUserMedia(constraints);
        this.video.srcObject = this.stream;
        
        return true;
    } catch (e) {
        console.error('Camera error:', e);
        return false;
    }
}

switch() {
    this.facingMode = this.facingMode === 'environment' ? 'user' : 'environment';
    this.start();
}

capture() {
    this.canvas.width = this.video.videoWidth;
    this.canvas.height = this.video.videoHeight;
    this.ctx.drawImage(this.video, 0, 0);
    return this.canvas.toDataURL('image/jpeg', 0.95);
}

stop() {
    if (this.stream) {
        this.stream.getTracks().forEach(t => t.stop());
    }
}
```

}

// ==================== Ù…Ø¯ÙŠØ± Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© ====================

class UIManager {
constructor(app) {
this.app = app;
}

```
showLoading(message = 'Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù„ÙŠÙ„...', subtext = '') {
    const html = `
        <div class="loading-overlay">
            <div class="spinner"></div>
            <div class="loading-text">${message}</div>
            <div class="loading-subtext">${subtext}</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>
    `;
    document.body.insertAdjacentHTML('beforeend', html);
}

updateProgress(percent) {
    const fill = document.getElementById('progressFill');
    if (fill) fill.style.width = percent + '%';
}

hideLoading() {
    const overlay = document.querySelector('.loading-overlay');
    if (overlay) overlay.remove();
}

showToast(message) {
    const toast = document.createElement('div');
    toast.className = 'toast';
    toast.textContent = message;
    document.body.appendChild(toast);
    setTimeout(() => toast.remove(), 3000);
}

displayResults(analysis) {
    const best = analysis.bestMove;
    
    // Ø¹Ø±Ø¶ Ø§Ù„Ø­Ø±ÙƒØ©
    document.getElementById('fromSquare').textContent = best.from;
    document.getElementById('toSquare').textContent = best.to;
    
    // Ø¹Ø±Ø¶ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…
    const evalBadge = document.getElementById('evalBadge');
    const evalValue = document.getElementById('evalValue');
    const score = best.score;
    
    evalValue.textContent = score > 0 ? `+${score.toFixed(1)}` : score.toFixed(1);
    
    evalBadge.className = 'eval-badge';
    if (score > 1) evalBadge.classList.add('positive');
    else if (score < -1) evalBadge.classList.add('negative');
    else evalBadge.classList.add('neutral');
    
    // Ø§Ù„Ø«Ù‚Ø©
    const confidence = Math.min(100, 70 + Math.abs(score) * 5);
    const confidenceFill = document.getElementById('confidenceFill');
    confidenceFill.style.width = confidence + '%';
    confidenceFill.textContent = Math.round(confidence) + '%';
    
    // Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
    document.getElementById('depthValue').textContent = analysis.depth;
    document.getElementById('nodesValue').textContent = this.formatNumber(analysis.nodes);
    document.getElementById('timeValue').textContent = analysis.time.toFixed(1);
    document.getElementById('npsValue').textContent = this.formatNumber(analysis.nps);
    
    // Ø£ÙØ¶Ù„ 10 Ø­Ø±ÙƒØ§Øª
    this.displayTopMoves(analysis.moves);
    
    // Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª
    this.displayStrategies(analysis);
    
    // ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù‚Ø·Ø¹
    this.displayPieceCount(analysis.board);
    
    // Ø§Ù„Ù„ÙˆØ­Ø©
    this.displayBoard(analysis.board, best);
    
    // Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ù†ØªØ§Ø¦Ø¬
    document.getElementById('resultContainer').classList.remove('hidden');
}

displayTopMoves(moves) {
    const container = document.getElementById('topMovesList');
    container.innerHTML = moves.map((m, i) => `
        <div class="move-item">
            <div class="move-rank">${i + 1}</div>
            <div class="move-text">${m.from} â†’ ${m.to}</div>
            <div class="move-eval">${m.score > 0 ? '+' : ''}${m.score.toFixed(1)}</div>
        </div>
    `).join('');
}

displayStrategies(analysis) {
    const strategies = this.analyzeStrategies(analysis);
    const container = document.getElementById('strategiesContainer');
    
    container.innerHTML = strategies.map(s => `
        <div class="strategy-card">
            <div class="strategy-title">${s.title}</div>
            <div class="strategy-desc">${s.description}</div>
        </div>
    `).join('');
}

analyzeStrategies(analysis) {
    const strategies = [];
    const score = analysis.bestMove.score;
    
    if (score > 2) {
        strategies.push({
            title: 'âš¡ Ù‡Ø¬ÙˆÙ… Ù‚ÙˆÙŠ',
            description: 'Ù…ÙˆÙ‚ÙÙƒ Ù…Ù…ØªØ§Ø²! Ø§Ø³ØªÙ…Ø± ÙÙŠ Ø§Ù„Ø¶ØºØ· ÙˆØ§Ù„Ø¨Ø­Ø« Ø¹Ù† ÙØ±Øµ ØªÙƒØªÙŠÙƒÙŠØ©'
        });
    }
    
    if (Math.abs(score) < 0.5) {
        strategies.push({
            title: 'âš–ï¸ Ù„Ø¹Ø¨ Ù…ØªÙˆØ§Ø²Ù†',
            description: 'Ø§Ù„Ù…ÙˆÙ‚Ù Ù…ØªÙˆØ§Ø²Ù†. Ø±ÙƒØ² Ø¹Ù„Ù‰ ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù…ÙˆÙ‚Ø¹ ÙˆØªØ·ÙˆÙŠØ± Ø§Ù„Ù‚Ø·Ø¹'
        });
    }
    
    strategies.push({
        title: 'ğŸ¯ Ø§Ù„Ø³ÙŠØ·Ø±Ø© Ø¹Ù„Ù‰ Ø§Ù„ÙˆØ³Ø·',
        description: 'Ø³ÙŠØ·Ø± Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø±Ø¨Ø¹Ø§Øª Ø§Ù„Ù…Ø±ÙƒØ²ÙŠØ© (d4, d5, e4, e5) Ù„ØªØ­Ø³ÙŠÙ† Ù…ÙˆÙ‚ÙÙƒ'
    });
    
    strategies.push({
        title: 'ğŸ° Ø£Ù…Ø§Ù† Ø§Ù„Ù…Ù„Ùƒ',
        description: 'ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ù…Ø§ÙŠØ© Ù…Ù„ÙƒÙƒ Ø¨Ø§Ù„Ø¨ÙŠØ§Ø¯Ù‚ ÙˆØ§Ù„ØªØ¨ÙŠÙŠØª ÙÙŠ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ù†Ø§Ø³Ø¨'
    });
    
    strategies.push({
        title: 'â™Ÿï¸ Ø¨Ù†ÙŠØ© Ø§Ù„Ø¨ÙŠØ§Ø¯Ù‚',
        description: 'ØªØ¬Ù†Ø¨ Ø§Ù„Ø¨ÙŠØ§Ø¯Ù‚ Ø§Ù„Ù…Ø²Ø¯ÙˆØ¬Ø© ÙˆØ­Ø§ÙˆÙ„ Ø¥Ù†Ø´Ø§Ø¡ Ø¨ÙŠØ§Ø¯Ù‚ Ø¹Ø§Ø¨Ø±Ø©'
    });
    
    return strategies;
}

displayPieceCount(board) {
    const count = {w: {}, b: {}};
    
    for (let sq in board) {
        const piece = board[sq];
        if (!piece) continue;
        const color = piece[0];
        const type = piece[1];
        count[color][type] = (count[color][type] || 0) + 1;
    }
    
    const symbols = {
        'P': 'â™™/â™Ÿ', 'N': 'â™˜/â™', 'B': 'â™—/â™',
        'R': 'â™–/â™œ', 'Q': 'â™•/â™›', 'K': 'â™”/â™š'
    };
    
    const types = ['Q', 'R', 'B', 'N', 'P'];
    const html = types.map(type => {
        const wCount = count.w[type] || 0;
        const bCount = count.b[type] || 0;
        const [wSymbol, bSymbol] = symbols[type].split('/');
        
        if (wCount === 0 && bCount === 0) return '';
        
        return `
            <div class="piece-count-item">
                <div class="piece-icon">${wSymbol}${bSymbol}</div>
                <div class="piece-number">${wCount} : ${bCount}</div>
            </div>
        `;
    }).join('');
    
    document.getElementById('pieceCount').innerHTML = html;
}

displayBoard(board, bestMove) {
    const container = document.getElementById('boardGrid');
    container.innerHTML = '';
    
    const symbols = {
        'wP':'â™™','wN':'â™˜','wB':'â™—','wR':'â™–','wQ':'â™•','wK':'â™”',
        'bP':'â™Ÿ','bN':'â™','bB':'â™','bR':'â™œ','bQ':'â™›','bK':'â™š'
    };
    
    for (let row = 8; row >= 1; row--) {
        for (let col = 0; col < 8; col++) {
            const file = String.fromCharCode(97 + col);
            const sq = file + row;
            
            const div = document.createElement('div');
            div.className = 'square';
            
            if ((row + col) % 2 === 0) div.classList.add('dark');
            else div.classList.add('light');
            
            if (sq === bestMove.from || sq === bestMove.to) {
                div.classList.add('highlight');
            }
            
            if (board[sq]) {
                div.textContent = symbols[board[sq]] || board[sq];
            }
            
            container.appendChild(div);
        }
    }
}

formatNumber(num) {
    if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
    if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
    return num.toString();
}
```

}

// ==================== Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ ====================

class ChessVisionApp {
constructor() {
this.camera = new CameraManager();
this.engine = new GrandMasterEngine();
this.detector = new VisionDetector();
this.ui = new UIManager(this);

```
    this.init();
}

init() {
    document.getElementById('startCamera').onclick = () => this.startCamera();
    document.getElementById('analyzeBtn').onclick = () => this.analyze();
    document.getElementById('switchCamera').onclick = () => this.camera.switch();
    document.getElementById('toggleGuide').onclick = () => this.toggleGuide();
    document.getElementById('resetBtn').onclick = () => this.reset();
}

async startCamera() {
    const success = await this.camera.start();
    if (success) {
        document.getElementById('startCamera').classList.add('hidden');
        document.getElementById('analyzeBtn').classList.remove('hidden');
        document.getElementById('switchCamera').classList.remove('hidden');
        document.getElementById('resetBtn').classList.remove('hidden');
        this.ui.showToast('âœ… Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø¬Ø§Ù‡Ø²Ø©!');
    } else {
        this.ui.showToast('âŒ ÙØ´Ù„ ÙØªØ­ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§');
    }
}

toggleGuide() {
    document.getElementById('guideCard').classList.toggle('hidden');
}

reset() {
    document.getElementById('resultContainer').classList.add('hidden');
    this.ui.showToast('ğŸ”„ ØªÙ… Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø¶Ø¨Ø·');
}

async analyze() {
    this.ui.showLoading(
        'ğŸ§  ØªØ­Ù„ÙŠÙ„ Ø¹Ù…ÙŠÙ‚ Ø¬Ø§Ø±ÙŠ...',
        'Ø¬Ø§Ø±ÙŠ ÙØ­Øµ Ø£ÙƒØ«Ø± Ù…Ù† 100,000 Ù…ÙˆÙ‚Ù'
    );
    
    try {
        // Ø§Ù„ØªÙ‚Ø§Ø· Ø§Ù„ØµÙˆØ±Ø©
        this.ui.updateProgress(10);
        const imageData = this.camera.capture();
        
        // ÙƒØ´Ù Ø§Ù„Ù„ÙˆØ­Ø©
        this.ui.updateProgress(30);
        await new Promise(r => setTimeout(r, 300));
        const board = await this.detector.analyzeImage(imageData);
        
        // ØªØ­Ù„ÙŠÙ„ Grand Master
        this.ui.updateProgress(50);
        await new Promise(r => setTimeout(r, 200));
        
        this.ui.updateProgress(70);
        const analysis = this.engine.findBestMoves(board, 6, 10);
        
        this.ui.updateProgress(90);
        analysis.board = board;
        
        // Ø¹Ø±Ø¶ Ø§Ù„Ù†ØªØ§Ø¦Ø¬
        await new Promise(r => setTimeout(r, 300));
        this.ui.updateProgress(100);
        
        await new Promise(r => setTimeout(r, 500));
        this.ui.hideLoading();
        this.ui.displayResults(analysis);
        
        this.ui.showToast('âœ… Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§ÙƒØªÙ…Ù„!');
        
    } catch (error) {
        console.error(error);
        this.ui.hideLoading();
        this.ui.showToast('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù„ÙŠÙ„');
    }
}
```

}

// ØªØ´ØºÙŠÙ„ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚
let app;
document.addEventListener(â€˜DOMContentLoadedâ€™, () => {
app = new ChessVisionApp();
});
</script>

</body>
</html>
